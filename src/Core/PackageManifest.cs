using Mefino.LightJson;
using Mefino.LightJson.Serialization;
using Mefino.Web;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mefino.Core
{
    public class PackageManifest
    {
        /// <summary>
        /// (Readonly) Unique ID for this package, which is generated from: "<c>{author} {name}</c>"
        /// </summary>
        public string GUID => $"{author} {name}";

        /// <summary>
        /// Install folder for the package in the Plugins folder.<br /><br />
        /// Will be the same as <see cref="GUID"/> unless <see cref="override_folder"/> was set, in which case it would be: <c>author overridefolder</c>
        /// </summary>
        public string InstallFolder => author + " " + (string.IsNullOrEmpty(override_folder)
                                                           ? name
                                                           : override_folder);

        /// <summary>
        /// An implicitly determined URL for this package, determined by "https://github.com/<c>{author}</c>/<c>{name}</c>"
        /// </summary>
        internal string GithubURL => $"https://github.com/{author}/{name}";

        /// <summary>
        /// Is a packge with this GUID installed? (May not literally be this package instance that is installed, if this is a web manifest)
        /// </summary>
        public bool IsInstalled => LocalPackageManager.TryGetInstalledPackage(GUID) != null;

        /// <summary>
        /// Whether this package is disabled or not.
        /// </summary>
        internal bool IsDisabled => LocalPackageManager.s_disabledPackages.ContainsKey(GUID);

        #region JSON

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Author name, or GitHub username where the package repository is hosted.</summary>
        public string author;

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Name of the package, and also the name of the repository.</summary>
        public string name;

        /// <summary>Version of the package, eg. 1.0.0.0</summary>
        public string version;

        /// <summary>
        /// [OPTIONAL] If set, this will be used instead of your <c>name</c> when installing your package.<br />
        /// Meaning that instead of installing at <c>plugins\{author} {name}\</c>, it will be installed at <c>plugins\{author} {override_folder}\</c><br /><br />
        /// This does not affect your <see cref="GUID"/>.
        /// </summary>
        public string override_folder;

        /// <summary>Short description of the package</summary>
        public string description;

        /// <summary>List of dependency GUIDs for this package</summary>
        public string[] dependencies = new string[0];

        /// <summary>List of conflicting GUIDs for this package</summary>
        public string[] conflicts_with = new string[0];

        /// <summary>True if this package should be installed by all players online, false if it doesn't matter.</summary>
        public bool require_sync;

        /// <summary>
        /// [INTERNAL] The time the manifest was cached from the web, for web manifests.
        /// This is currently just used to decide if we should download the manifest.json again or not.
        /// </summary>
        public string m_manifestCachedTime;

        #endregion

        /// <summary>
        /// Only used in C# by Mefino. The install state of the package.
        /// </summary>
        internal InstallState m_installState;

        /// <summary>
        /// Returns a more human-readable form of <see cref="m_installState"/>.
        /// </summary>
        public string InstallStateToString()
        {
            switch (this.m_installState)
            {
                case InstallState.Installed:
                    return IsDisabled ? "Disabled" : "Ready";
                case InstallState.MissingDependency:
                    return "Missing dependencies";
                case InstallState.NotInstalled:
                    return "Not installed";
                case InstallState.HasConflict:
                    return "Has conflicts";
                case InstallState.Outdated:
                    return "Outdated";
                default:
                    throw new NotImplementedException($"Not implemented: {m_installState}");
            }
        }

        /// <summary>
        /// Check if the version of this package instance is greater than the version of the other package instance, or optionally check if equal version.
        /// </summary>
        /// <param name="other">The other package to check against, presumably the same GUID.</param>
        /// <param name="greaterOrEqual">Allow equal to return true?</param>
        /// <returns><see langword="true"/> if this version is greater than the other package (or equal when <paramref name="greaterOrEqual"/> is <see langword="true"/>), 
        /// otherwise <see langword="false"/>.</returns>
        public bool IsGreaterVersionThan(PackageManifest other, bool greaterOrEqual = false)
        {
            Version otherVersion;
            try
            {
                otherVersion = new Version(other.version);
            }
            catch { return true; }

            Version thisVersion;
            try
            {
                thisVersion = new Version(this.version);
            }
            catch { return false; }

            return greaterOrEqual
                    ? thisVersion >= otherVersion
                    : thisVersion > otherVersion;
        }

        /// <summary>
        /// Check this package's <see cref="m_manifestCachedTime"/> is equal to or more recent than the <paramref name="utcTimeString"/>.
        /// </summary>
        /// <param name="utcTimeString">A UTC time string to check against.</param>
        /// <returns><see langword="true"/> if cached since or at the same time as the string, otherwise <see langword="false"/></returns>
        internal bool IsManifestCachedSince(string utcTimeString)
        {
            DateTime timeToCheck;
            try
            {
                timeToCheck = DateTime.Parse(utcTimeString);
            }
            catch
            {
                Console.WriteLine("Exception parsing utc time string " + utcTimeString);
                // default to true if unable to parse the string to check against
                return true;
            }

            DateTime thisTime;
            try
            {
                thisTime = DateTime.Parse(this.m_manifestCachedTime);
            }
            catch
            {
                Console.WriteLine("Exception parsing manifest cache time: " + m_manifestCachedTime);
                // default to false if unable to parse existing manifest time
                return false;
            }

            return timeToCheck <= thisTime;
        }

        /// <summary>
        /// Check if this package is dependant upon the <paramref name="otherGuid"/> (meaning this <see cref="dependencies"/> contains the <paramref name="otherGuid"/>).
        /// </summary>
        /// <param name="otherGuid">The other <see cref="GUID"/> to check for</param>
        /// <returns><see langword="true"/> if this package is dependant upon the <paramref name="otherGuid"/>, otherwise <see langword="false"/></returns>
        public bool IsDependantUpon(string otherGuid)
        {
            if (this.dependencies == null || !this.dependencies.Any())
                return false;

            return this.dependencies.Contains(otherGuid);
        }

        /// <summary>
        /// Check if all packages which this package depends upon are enabled.
        /// </summary>
        /// <param name="missing">If any dependencies are missing, this will contain their <see cref="GUID"/>s.</param>
        /// <returns><see langword="true"/> if all dependencies enabled (or there are no dependencies), otherwise <see langword="false"/></returns>
        public bool AreAllDependenciesEnabled(out List<string> missing)
        {
            missing = new List<string>();

            if (this.dependencies == null || !this.dependencies.Any())
                return true;

            bool ret = true;
            foreach (var dep in this.dependencies)
            {
                if (!LocalPackageManager.s_enabledPackages.ContainsKey(dep))
                {
                    missing.Add(dep);
                    ret = false;
                }
            }

            return ret;
        }

        /// <summary>
        /// Enable all dependencies for this package, and optionally download and install them if missing.
        /// </summary>
        /// <param name="forceInstall">If true, will download and install missing dependencies.</param>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/>.</returns>
        public bool TryEnableAllDependencies(bool forceInstall)
        {
            bool ret = true;

            if (this.dependencies != null && this.dependencies.Any())
            {
                foreach (var dep in this.dependencies)
                {
                    var pkg = LocalPackageManager.TryGetInstalledPackage(dep);

                    if (pkg == null)
                    {
                        if (!forceInstall)
                            return false;
                        else if (!LocalPackageManager.TryInstallWebPackage(dep, true))
                        {
                            Console.WriteLine("LPM.TryInstallWebPackage return false?");
                            return false;
                        }
                    }
                    else if (pkg.IsDisabled && !LocalPackageManager.TryEnablePackage(dep))
                    {
                        return false;
                    }
                }
            }

            return ret;
        }

        /// <summary>
        /// Get a list of <b>enabled</b> <see cref="GUID"/>s which are dependant upon this package.
        /// </summary>
        /// <returns>If any, a list of enabled package GUIDs which are dependant on this package, otherwise an empty list.</returns>
        public List<string> GetCurrentlyEnabledDependantPackages()
        {
            var ret = new List<string>();

            foreach (var package in LocalPackageManager.s_enabledPackages)
            {
                if (package.Value.IsDependantUpon(this.GUID))
                    ret.Add(package.Key);
            }

            return ret;
        }

        /// <summary>
        /// Disable all packages which depend on this package.
        /// </summary>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/>.</returns>
        public void TryDisableAllDependencies()
        {
            var packages = GetCurrentlyEnabledDependantPackages();

            foreach (var pkg in packages)
            {
                LocalPackageManager.TryDisablePackage(pkg, true);
            }
        }

        /// <summary>
        /// Check if this package declares a conflict with the other package (meaning this <see cref="conflicts_with"/> contains <paramref name="otherGuid"/>.
        /// </summary>
        /// <param name="otherGuid"></param>
        /// <returns></returns>
        public bool HasConflictWith(string otherGuid)
        {
            if (this.conflicts_with == null || !this.conflicts_with.Any())
                return false;

            return this.conflicts_with.Contains(otherGuid);
        }

        /// <summary>
        /// Check if any enabled packages are in this package's <see cref="conflicts_with"/> list.
        /// </summary>
        /// <returns><see langword="true"/> if there were any enabled conflicts found, otherwise <see langword="false"/></returns>
        public bool HasAnyEnabledConflicts(out List<string> conflicts)
        {
            conflicts = new List<string>();
            bool ret = false;

            if (this.conflicts_with != null && this.conflicts_with.Any())
            {
                ret = conflicts_with.Any(it => LocalPackageManager.s_enabledPackages.ContainsKey(it));
                if (ret)
                    conflicts.AddRange(LocalPackageManager.s_enabledPackages.Keys.Where(it => conflicts_with.Contains(it)));
            }

            return ret;
        }

        /// <summary>
        /// Gets enabled packages which declare a conflict with this package. This differs from HasAnyEnabledConflicts (which checks this package's conflicts_with list),
        /// instead this package checks other packages' conflicts_with for this GUID.
        /// </summary>
        /// <returns>GUIDs of any enabled packages which declare a conflict with this package.</returns>
        public List<string> GetEnabledConflictsAlternate()
        {
            var ret = new List<string>();

            foreach (var pkg in LocalPackageManager.s_enabledPackages.Values)
            {
                if (pkg.conflicts_with?.Contains(this.GUID) ?? false)
                    ret.Add(pkg.GUID);
            }

            return ret;
        }

        /// <summary>
        /// Try to disable all enabled conflicts with this package (all GUIDs inside this <see cref="conflicts_with"/> list).
        /// </summary>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/></returns>
        public bool TryDisableAllConflicts()
        {
            bool ret = true;

            if (this.conflicts_with != null && this.conflicts_with.Any())
            {
                foreach (var guid in this.conflicts_with)
                {
                    if (LocalPackageManager.s_enabledPackages.ContainsKey(guid))
                    {
                        if (!LocalPackageManager.TryDisablePackage(guid, true))
                            return false;
                    }
                }
            }

            return ret;
        }

        /// <summary>
        /// Convert this package to JSON.
        /// </summary>
        /// <returns>A <see cref="JsonObject"/> containing all the serialized data of this manifest.</returns>
        public JsonObject ToJsonObject()
        {
            var ret = new JsonObject
            {
                { nameof(GUID),                 this.GUID },
                { nameof(author),               this.author },
                { nameof(name),                 this.name },
                { nameof(version),              this.version },
                { nameof(description),          this.description },
                { nameof(override_folder),      this.override_folder },
                { nameof(require_sync),         this.require_sync },
                { nameof(m_manifestCachedTime), this.m_manifestCachedTime },
            };

            if (this.dependencies != null)
                ret.Add(nameof(dependencies), new JsonArray(this.dependencies.Select(it => new JsonValue(it))
                                                                             .ToArray()));
            else
                ret.Add(nameof(dependencies), new JsonArray(new JsonValue[0]));

            if (this.conflicts_with != null)
                ret.Add(nameof(conflicts_with), new JsonArray(this.conflicts_with.Select(it => new JsonValue(it))
                                                                                 .ToArray()));
            else
                ret.Add(nameof(conflicts_with), new JsonArray(new JsonValue[0]));

            return ret;
        }

        /// <summary>
        /// Deserialize a package from a given JSON string (eg, the result of <see cref="JsonObject.ToString"/>).
        /// </summary>
        /// <param name="jsonString">A valid JSON string to deserialize.</param>
        /// <returns>A deserialized package if successful, otherwise <see langword="null"/>.</returns>
        internal static PackageManifest FromManifestJson(string jsonString)
        {
            try
            {
                var json = JsonReader.Parse(jsonString);

                var ret = new PackageManifest
                {
                    author = json[nameof(author)].AsString,
                    name = json[nameof(name)].AsString,
                    version = json[nameof(version)].AsString
                };

                if (json[nameof(description)].AsString is string desc)
                    ret.description = desc;

                if (json[nameof(require_sync)].AsBoolean is bool requiresSync)
                    ret.require_sync = requiresSync;

                if (json[nameof(override_folder)].AsString is string folder)
                    ret.override_folder = folder;

                if (json[nameof(dependencies)].AsJsonArray is JsonArray deps)
                    ret.dependencies = deps.Select(it => it.AsString)?.ToArray();

                if (json[nameof(conflicts_with)].AsJsonArray is JsonArray conflicts)
                    ret.conflicts_with = conflicts.Select(it => it.AsString)?.ToArray();

                if (json[nameof(m_manifestCachedTime)].AsString is string cachetime)
                    ret.m_manifestCachedTime = cachetime;

                return ret;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Exception parsing PackageManifest from Json!");
                Console.WriteLine(ex);
                //Console.WriteLine("Json string: " + jsonString);
                return default;
            }
        }
    }
}
