using Mefino.LightJson;
using Mefino.LightJson.Serialization;
using Mefino.Core.Web;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mefino.Core
{
    public class PackageManifest
    {
        /// <summary>
        /// (Readonly) Unique ID for this package, which is generated from: "<c>{author} {name}</c>"
        /// </summary>
        public string GUID => $"{author} {name}";

        /// <summary>
        /// An implicitly determined URL for this package, determined by "https://github.com/<c>{author}</c>/<c>{repository}</c>"
        /// </summary>
        public string GithubURL => $"https://github.com/{author}/{repository}";

        public string GithubDownloadURL => $"{GithubURL}/releases/latest/download/{DownloadFileName}";

        public string DownloadFileName
        {
            get
            {
                string ret = string.IsNullOrEmpty(download_filename) ? $"{name}" : $"{download_filename}";
                if (ret.EndsWith(".zip", StringComparison.OrdinalIgnoreCase))
                    ret = ret.Substring(0, ret.Length - 4);
                return $"{ret}.zip";
            }
        }

        public DateTime RepoLastUpdatedTime
        {
            get
            {
                var repoGuid = $"{author} {repository}";
                WebManifestManager.s_repoCacheTimes.TryGetValue(repoGuid, out DateTime time);
                return time;
            }
        }

        private const decimal AVG_MONTH = 30.4375m;

        public string TimeSinceRepoUpdatedPretty
        {
            get
            {
                var time = RepoLastUpdatedTime;
                string timeString;
                if (time == default)
                    timeString = $"Unknown";
                else
                {
                    var diff = DateTime.Now - RepoLastUpdatedTime;
                    if ((decimal)diff.TotalDays >= AVG_MONTH)
                    {
                        int mths = (int)Math.Floor((decimal)diff.TotalDays / AVG_MONTH);
                        timeString = $"{mths:F0} month";
                    }
                    else if (diff.TotalDays >= 1)
                        timeString = $"{diff.TotalDays:F0} day";
                    else if (diff.TotalHours >= 1)
                        timeString = $"{diff.TotalHours:F0} hour";
                    else
                        timeString = $"{Math.Ceiling(diff.TotalMinutes):F0} minute";

                    if (int.Parse(timeString.Substring(0, timeString.LastIndexOf(' '))) != 1)
                        timeString += "s";
                    timeString += " ago";
                }
                return timeString;
            }
        }

        /// <summary>
        /// Is a packge with this GUID installed? (May not literally be this package instance that is installed, if this is a web manifest)
        /// </summary>
        public bool IsInstalled => LocalPackageManager.TryGetInstalledPackage(GUID) != null;

        /// <summary>
        /// Is this package installed and disabled?
        /// </summary>
        internal bool IsDisabled => LocalPackageManager.s_disabledPackages.ContainsKey(GUID);

        #region JSON

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Author name, or GitHub username where the package repository is hosted.</summary>
        public string author;

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Name of the repository where the package is hosted (on <see cref="author"/>'s account).</summary>
        public string repository;

        /// <summary>Name of the package, and the name of the install folder (<c>plugins\{author} {name}\</c>)</summary>
        public string name;

        /// <summary>Version of the package, eg. 1.0.0.0</summary>
        public string version;

        /// <summary>Short description of the package</summary>
        public string description;

        /// <summary></summary>
        public string[] tags = new string[0];

        /// <summary>List of dependency GUIDs for this package</summary>
        public string[] dependencies = new string[0];

        /// <summary>List of conflicting GUIDs for this package</summary>
        public string[] conflicts_with = new string[0];

        /// <summary>True if this package should be installed by all players online, false if it doesn't matter.</summary>
        public bool require_sync;

        /// <summary>
        /// [OPTIONAL] If set, Mefino will look for a file called <c>{download_filename}.zip</c> instead of <c>{name}.zip</c> in the specified repository.
        /// </summary>
        public string download_filename;

        #endregion

        private HashSet<string> m_tags;
        public bool HasTag(string tag)
        {
            if (m_tags == null)
            {
                m_tags = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                foreach (string t in this.tags)
                {
                    m_tags.Add(t);
                }
            }

            return m_tags.Contains(tag);
        }

        /// <summary>
        /// Only used in C# by Mefino. The install state of the package.
        /// </summary>
        internal InstallState m_installState;

        /// <summary>
        /// Returns a more human-readable form of <see cref="m_installState"/>.
        /// </summary>
        public string InstallStateToString()
        {
            switch (this.m_installState)
            {
                case InstallState.Installed:
                    return IsDisabled ? "Disabled" : "Ready";
                case InstallState.MissingDependency:
                    return "Missing dependencies";
                case InstallState.NotInstalled:
                    return "Not installed";
                case InstallState.NotWorking:
                    return "Not working";
                case InstallState.HasConflict:
                    return "Has conflicts";
                case InstallState.Outdated:
                    return "Outdated";
                default:
                    throw new NotImplementedException($"Not implemented: {m_installState}");
            }
        }

        /// <summary>
        /// Check if the version of this package instance is greater than the version of the other package instance, or optionally check if equal version.
        /// </summary>
        /// <param name="other">The other package to check against, presumably the same GUID.</param>
        /// <param name="greaterOrEqual">Allow equal to return true?</param>
        /// <returns><see langword="true"/> if this version is greater than the other package (or equal when <paramref name="greaterOrEqual"/> is <see langword="true"/>), 
        /// otherwise <see langword="false"/>.</returns>
        public bool IsGreaterVersionThan(PackageManifest other, bool greaterOrEqual = false)
        {
            Version otherVersion;
            try
            {
                otherVersion = new Version(other.version);
            }
            catch { return true; }

            Version thisVersion;
            try
            {
                thisVersion = new Version(this.version);
            }
            catch { return false; }

            return greaterOrEqual
                    ? thisVersion >= otherVersion
                    : thisVersion > otherVersion;
        }

        /// <summary>
        /// Try to enable this package, and optionally all dependencies too.
        /// </summary>
        public bool TryEnable(bool tryEnableDependencies = true)
        {
            return LocalPackageManager.TryEnablePackage(this.GUID, tryEnableDependencies);
        }

        /// <summary>
        /// Try to disable this package.
        /// </summary>
        public bool TryDisable(bool skipWarnings = false)
        {
            return LocalPackageManager.TryDisablePackage(this.GUID, skipWarnings);
        }

        /// <summary>
        /// Try to install this package and optionally enable it.
        /// </summary>
        public bool TryInstall(bool andEnable)
        {
            return LocalPackageManager.TryInstallWebPackage(this.GUID, andEnable);
        }

        /// <summary>
        /// Try to uninstall this package.
        /// </summary>
        public bool TryUninstall()
        {
            return LocalPackageManager.TryUninstallPackage(this);
        }

        /// <summary>
        /// Check if this package is dependant upon the <paramref name="otherGuid"/> (meaning this <see cref="dependencies"/> contains the <paramref name="otherGuid"/>).
        /// </summary>
        /// <param name="otherGuid">The other <see cref="GUID"/> to check for</param>
        /// <returns><see langword="true"/> if this package is dependant upon the <paramref name="otherGuid"/>, otherwise <see langword="false"/></returns>
        public bool IsDependantUpon(string otherGuid)
        {
            if (this.dependencies == null || !this.dependencies.Any())
                return false;

            return this.dependencies.Contains(otherGuid);
        }

        /// <summary>
        /// Check if all packages which this package depends upon are enabled.
        /// </summary>
        /// <param name="missing">If any dependencies are missing, this will contain their <see cref="GUID"/>s.</param>
        /// <returns><see langword="true"/> if all dependencies enabled (or there are no dependencies), otherwise <see langword="false"/></returns>
        public bool AreAllDependenciesEnabled(out List<string> missing)
        {
            missing = new List<string>();

            if (this.dependencies == null || !this.dependencies.Any())
                return true;

            bool ret = true;
            foreach (var dep in this.dependencies)
            {
                if (!LocalPackageManager.s_enabledPackages.ContainsKey(dep))
                {
                    missing.Add(dep);
                    ret = false;
                }
            }

            return ret;
        }

        /// <summary>
        /// Enable all dependencies for this package, and optionally download and install them if missing.
        /// </summary>
        /// <param name="forceInstall">If true, will download and install missing dependencies.</param>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/>.</returns>
        public bool TryEnableAllDependencies(bool forceInstall)
        {
            bool ret = true;

            if (this.dependencies != null && this.dependencies.Any())
            {
                foreach (var dep in this.dependencies)
                {
                    var pkg = LocalPackageManager.TryGetInstalledPackage(dep);

                    if (pkg == null)
                    {
                        if (!forceInstall)
                            return false;
                        else if (!LocalPackageManager.TryInstallWebPackage(dep, true))
                        {
                            Console.WriteLine("LPM.TryInstallWebPackage return false?");
                            return false;
                        }
                    }
                    else if (pkg.IsDisabled && !LocalPackageManager.TryEnablePackage(dep))
                    {
                        return false;
                    }
                }
            }

            return ret;
        }

        /// <summary>
        /// Get a list of <b>enabled</b> <see cref="GUID"/>s which are dependant upon this package.
        /// </summary>
        /// <returns>If any, a list of enabled package GUIDs which are dependant on this package, otherwise an empty list.</returns>
        public List<string> GetCurrentlyEnabledDependantPackages()
        {
            var ret = new List<string>();

            foreach (var package in LocalPackageManager.s_enabledPackages)
            {
                if (package.Value.IsDependantUpon(this.GUID))
                    ret.Add(package.Key);
            }

            return ret;
        }

        /// <summary>
        /// Disable all packages which depend on this package.
        /// </summary>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/>.</returns>
        public void TryDisableAllDependencies()
        {
            var packages = GetCurrentlyEnabledDependantPackages();

            foreach (var pkg in packages)
            {
                LocalPackageManager.TryDisablePackage(pkg, true);
            }
        }

        /// <summary>
        /// Check if this package declares a conflict with the other package (meaning this <see cref="conflicts_with"/> contains <paramref name="otherGuid"/>.
        /// </summary>
        /// <param name="otherGuid"></param>
        /// <returns></returns>
        public bool HasConflictWith(string otherGuid)
        {
            if (this.conflicts_with == null || !this.conflicts_with.Any())
                return false;

            return this.conflicts_with.Contains(otherGuid);
        }

        /// <summary>
        /// Check if any enabled packages are in this package's <see cref="conflicts_with"/> list.
        /// </summary>
        /// <returns><see langword="true"/> if there were any enabled conflicts found, otherwise <see langword="false"/></returns>
        public bool HasAnyEnabledConflicts(out List<string> conflicts)
        {
            conflicts = new List<string>();
            bool ret = false;

            if (this.conflicts_with != null && this.conflicts_with.Any())
            {
                ret = conflicts_with.Any(it => LocalPackageManager.s_enabledPackages.ContainsKey(it));
                if (ret)
                    conflicts.AddRange(LocalPackageManager.s_enabledPackages.Keys.Where(it => conflicts_with.Contains(it)));
            }

            return ret;
        }

        /// <summary>
        /// Gets enabled packages which declare a conflict with this package. This differs from HasAnyEnabledConflicts (which checks this package's conflicts_with list),
        /// instead this package checks other packages' conflicts_with for this GUID.
        /// </summary>
        /// <returns>GUIDs of any enabled packages which declare a conflict with this package.</returns>
        public List<string> GetEnabledConflictsAlternate()
        {
            var ret = new List<string>();

            foreach (var pkg in LocalPackageManager.s_enabledPackages.Values)
            {
                if (pkg.conflicts_with?.Contains(this.GUID) ?? false)
                    ret.Add(pkg.GUID);
            }

            return ret;
        }

        /// <summary>
        /// Try to disable all enabled conflicts with this package (all GUIDs inside this <see cref="conflicts_with"/> list).
        /// </summary>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/></returns>
        public bool TryDisableAllConflicts()
        {
            bool ret = true;

            if (this.conflicts_with != null && this.conflicts_with.Any())
            {
                foreach (var guid in this.conflicts_with)
                {
                    if (LocalPackageManager.s_enabledPackages.ContainsKey(guid))
                    {
                        if (!LocalPackageManager.TryDisablePackage(guid, true))
                            return false;
                    }
                }
            }

            return ret;
        }

        /// <summary>
        /// Convert this package to JSON.
        /// </summary>
        /// <returns>A <see cref="JsonObject"/> containing all the serialized data of this manifest.</returns>
        public JsonObject ToJsonObject()
        {
            var ret = new JsonObject
            {
                { nameof(GUID),                 this.GUID },
                { nameof(repository),           this.repository },
                { nameof(author),               this.author },
                { nameof(name),                 this.name },
                { nameof(version),              this.version },
                { nameof(description),          this.description },
                { nameof(download_filename),    this.download_filename },
                { nameof(require_sync),         this.require_sync },
                //{ nameof(m_manifestCachedTime), this.m_manifestCachedTime },
            };

            AddJsonStringArraySafe(ret, nameof(this.tags), this.tags);
            AddJsonStringArraySafe(ret, nameof(this.dependencies), this.dependencies);
            AddJsonStringArraySafe(ret, nameof(this.conflicts_with), this.conflicts_with);

            return ret;
        }

        private static void AddJsonStringArraySafe(JsonObject json, string name, string[] array)
        {
            if (array != null)
                json.Add(name, new JsonArray(array.Select(it => new JsonValue(it)).ToArray()));
            else
                json.Add(name, new JsonArray(new JsonValue[0]));
        }

        /// <summary>
        /// Deserialize a package from a given JSON string (eg, the result of <see cref="JsonObject.ToString"/>).
        /// </summary>
        /// <param name="jsonString">A valid JSON string to deserialize.</param>
        /// <returns>A deserialized package if successful, otherwise <see langword="null"/>.</returns>
        internal static PackageManifest FromManifestJson(string jsonString)
        {
            try
            {
                var json = JsonReader.Parse(jsonString);

                var ret = new PackageManifest
                {
                    author = json[nameof(author)].AsString,
                    repository = json[nameof(repository)].AsString,
                    name = json[nameof(name)].AsString,
                    version = json[nameof(version)].AsString,
                    description = json[nameof(description)].AsString,
                    download_filename = json[nameof(download_filename)].AsString,
                    require_sync = json[nameof(require_sync)].AsBoolean,
                };

                if (json[nameof(tags)].AsJsonArray is JsonArray tag)
                    ret.tags = tag.Select(it => it.AsString)?.ToArray();

                if (json[nameof(dependencies)].AsJsonArray is JsonArray deps)
                    ret.dependencies = deps.Select(it => it.AsString)?.ToArray();

                if (json[nameof(conflicts_with)].AsJsonArray is JsonArray conflicts)
                    ret.conflicts_with = conflicts.Select(it => it.AsString)?.ToArray();

                return ret;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Exception parsing PackageManifest from Json!");
                Console.WriteLine(ex);
                //Console.WriteLine("Json string: " + jsonString);
                return default;
            }
        }
    }
}
