using Mefino.LightJson;
using Mefino.LightJson.Serialization;
using Mefino.Web;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mefino.Core
{
    public class PackageManifest
    {
        /// <summary>
        /// (Readonly) Unique ID for this package, which is generated from: <c>author name</c>
        /// </summary>
        public string GUID => $"{author} {name}";

        /// <summary>
        /// Install folder for the package in the Plugins folder.<br /><br />
        /// Will be the same as <see cref="GUID"/> unless <see cref="override_folder"/> was set, in which case it would be: <c>author overridefolder</c>
        /// </summary>
        public string InstallFolder => author + " " + (string.IsNullOrEmpty(override_folder)
                                                           ? name
                                                           : override_folder);

        /// <summary>
        /// An implicitly determined URL for this package, determined by "https://github.com/<c>{author}</c>/<c>{name}</c>"
        /// </summary>
        internal string GithubURL => $"https://github.com/{author}/{name}";

        #region JSON

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Author name, or GitHub username where the package repository is hosted.</summary>
        public string author;

        /// <summary>[GENERATED BY MEFINO FOR WEB PACKAGES]<br />Name of the package, and also the name of the repository.</summary>
        public string name;

        /// <summary>Version of the package, eg. 1.0.0.0</summary>
        public string version;

        /// <summary>
        /// [OPTIONAL] If set, this will be used instead of your <c>name</c> when installing your package.<br />
        /// Meaning that instead of installing as <c>author name</c>, it will be installed as <c>author override_folder</c>.<br /><br />
        /// This does not affect your <see cref="GUID"/>.
        /// </summary>
        public string override_folder;

        /// <summary>Short description of the package</summary>
        public string description;

        /// <summary>List of dependency GUIDs for this package</summary>
        public string[] dependencies = new string[0];

        /// <summary>True if this package should be installed by all players online, false if it doesn't matter.</summary>
        public bool require_sync;

        /// <summary>
        /// [INTERNAL] The time the manifest was cached from the web, for web manifests.
        /// This is currently just used to decide if we should download the manifest.json again or not.
        /// </summary>
        public string m_manifestCachedTime;

        #endregion

        /// <summary>
        /// Only used in C# by Mefino. The install state of the package.
        /// </summary>
        internal InstallState m_installState;

        /// <summary>
        /// Only used in C# by Mefino. Whether this package is disabled or not.
        /// </summary>
        internal bool m_isDisabled;

        /// <summary>
        /// Check if this version of the package is greater version than another version of package, or optionally check if equal version.
        /// </summary>
        /// <param name="other">The other package to check against, presumably the same GUID.</param>
        /// <param name="greaterOrEqual">Allow equal to return true?</param>
        /// <returns><see langword="true"/> if this version is greater than the other package (or equal when <paramref name="greaterOrEqual"/> is <see langword="true"/>), 
        /// otherwise <see langword="false"/>.</returns>
        public bool IsGreaterVersionThan(PackageManifest other, bool greaterOrEqual = false)
        {
            Version otherVersion;
            try
            {
                otherVersion = new Version(other.version);
            }
            catch { return true; }

            Version thisVersion;
            try
            {
                thisVersion = new Version(this.version);
            }
            catch { return false; }

            return greaterOrEqual
                    ? thisVersion >= otherVersion
                    : thisVersion > otherVersion;
        }

        /// <summary>
        /// Check if this version of the manifest is cached at the same time or more recently than the <paramref name="utcTimeString"/>.
        /// </summary>
        /// <param name="utcTimeString">A UTC time string to check against.</param>
        /// <returns><see langword="true"/> if cached since or at the same time as the string, otherwise <see langword="false"/></returns>
        internal bool IsManifestCachedSince(string utcTimeString)
        {
            DateTime timeToCheck;
            try
            {
                timeToCheck = DateTime.Parse(utcTimeString);
            }
            catch
            {
                Console.WriteLine("Exception parsing utc time string " + utcTimeString);
                // default to true if unable to parse the string to check against
                return true;
            }

            DateTime thisTime;
            try
            {
                thisTime = DateTime.Parse(this.m_manifestCachedTime);
            }
            catch
            {
                Console.WriteLine("Exception parsing manifest cache time: " + m_manifestCachedTime);
                // default to false if unable to parse existing manifest time
                return false;
            }

            return timeToCheck <= thisTime;
        }

        /// <summary>
        /// Check if this package is dependant upon the <paramref name="otherGuid"/> (meaning this <see cref="dependencies"/> contains the <paramref name="otherGuid"/>).
        /// </summary>
        /// <param name="otherGuid">The other <see cref="GUID"/> to check for</param>
        /// <returns><see langword="true"/> if this package is dependant upon the <paramref name="otherGuid"/>, otherwise <see langword="false"/></returns>
        public bool IsDependantUpon(string otherGuid)
        {
            if (this.dependencies == null || !this.dependencies.Any())
                return false;

            return this.dependencies.Contains(otherGuid);
        }

        /// <summary>
        /// Get a list of <b>enabled</b> <see cref="GUID"/>s which are dependant upon this package.
        /// </summary>
        /// <returns>A list of enabled package GUIDs which are dependant on this package, otherwise an empty list.</returns>
        public List<string> GetDependantEnabledPackagesOfThis()
        {
            var ret = new List<string>();

            foreach (var package in LocalPackageManager.s_enabledPackages)
            {
                if (package.Value.IsDependantUpon(this.GUID))
                    ret.Add(package.Key);
            }

            return ret;
        }

        /// <summary>
        /// Check if all packages which this package depends upon are enabled.
        /// </summary>
        /// <param name="missing">If any dependencies are missing, this will contain their <see cref="GUID"/>s.</param>
        /// <returns><see langword="true"/> if all dependencies enabled (or there are no dependencies), otherwise <see langword="false"/></returns>
        public bool AreAllDependenciesEnabled(out List<string> missing)
        {
            missing = new List<string>();

            if (this.dependencies == null || !this.dependencies.Any())
                return true;

            bool ret = true;
            foreach (var dep in this.dependencies)
            {
                if (!LocalPackageManager.s_enabledPackages.ContainsKey(dep))
                {
                    missing.Add(dep);
                    ret = false;
                }
            }

            return ret;
        }

        /// <summary>
        /// Enable all dependencies for this package, and optionally download and install them if missing.
        /// </summary>
        /// <param name="forceInstall">If true, will download and install missing dependencies.</param>
        /// <returns><see langword="true"/> if successful, otherwise <see langword="false"/>.</returns>
        public bool TryEnableAllDependencies(bool forceInstall)
        {
            bool ret = true;

            if (this.dependencies != null && this.dependencies.Any())
            {
                foreach (var dep in this.dependencies)
                {
                    if (!LocalPackageManager.TryEnablePackage(dep) && forceInstall)
                    {
                        ret &= LocalPackageManager.TryInstallWebPackage(dep);
                    }
                    else
                        ret = false;
                }
            }

            return ret;
        }

        /// <summary>
        /// Convert this package to JSON.
        /// </summary>
        /// <returns>A <see cref="JsonObject"/> containing all the serialized data of this manifest.</returns>
        public JsonObject ToJsonObject()
        {
            return new JsonObject
            {
                { nameof(GUID),             this.GUID },

                { nameof(author),           this.author },
                { nameof(name),             this.name },
                { nameof(version),          this.version },
                { nameof(description),      this.description },
                { nameof(override_folder),  this.override_folder },
                { nameof(require_sync),     this.require_sync },
                {
                    nameof(dependencies),
                    new JsonArray(this.dependencies.Select(it => new JsonValue(it))
                                                   .ToArray())
                },
                { nameof(m_manifestCachedTime), this.m_manifestCachedTime },
            };
        }

        /// <summary>
        /// Deserialize a package from a given JSON string (eg, the result of <see cref="JsonObject.ToString"/>).
        /// </summary>
        /// <param name="jsonString">A valid JSON string to deserialize.</param>
        /// <returns>A deserialized package if successful, otherwise <see langword="null"/>.</returns>
        internal static PackageManifest FromManifestJson(string jsonString)
        {
            try
            {
                var json = JsonReader.Parse(jsonString);

                var ret = new PackageManifest
                {
                    author = json[nameof(author)].AsString,
                    name = json[nameof(name)].AsString,
                    version = json[nameof(version)].AsString
                };

                if (json[nameof(description)].AsString is string desc)
                    ret.description = desc;

                if (json[nameof(dependencies)].AsJsonArray is JsonArray deps)
                    ret.dependencies = deps.Select(it => it.AsString)?.ToArray();

                if (json[nameof(override_folder)].AsString is string folder)
                    ret.override_folder = folder;

                if (json[nameof(require_sync)].AsBoolean is bool requiresSync)
                    ret.require_sync = requiresSync;

                if (json[nameof(m_manifestCachedTime)].AsString is string cachetime)
                    ret.m_manifestCachedTime = cachetime;

                return ret;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Exception parsing PackageManifest from Json!");
                Console.WriteLine(ex);
                //Console.WriteLine("Json string: " + jsonString);
                return default;
            }
        }
    }
}
